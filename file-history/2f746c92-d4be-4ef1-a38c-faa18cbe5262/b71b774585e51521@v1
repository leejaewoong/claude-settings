"""
Post service for handling post CRUD operations
"""
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.dialects.postgresql import insert

from app.models.post import Post
from app.core.database import AsyncSessionLocal

logger = logging.getLogger(__name__)


async def save_posts(posts_data: List[Dict[str, Any]], session: Optional[AsyncSession] = None) -> Dict[str, int]:
    """
    Save or update posts to the database.
    Uses upsert (INSERT ... ON CONFLICT DO UPDATE) to handle duplicates.

    Args:
        posts_data: List of post dictionaries with keys:
            - source, external_id, title, content, url, author, created_at, comments, collected_at
        session: Optional database session. If not provided, creates a new one.

    Returns:
        Dictionary with counts: {"inserted": n, "updated": m, "failed": k}
    """
    if not posts_data:
        return {"inserted": 0, "updated": 0, "failed": 0}

    should_close = False
    if session is None:
        session = AsyncSessionLocal()
        should_close = True

    inserted_count = 0
    updated_count = 0
    failed_count = 0

    try:
        for post_data in posts_data:
            try:
                # Check if post already exists
                stmt = select(Post).where(Post.external_id == post_data["external_id"])
                result = await session.execute(stmt)
                existing_post = result.scalar_one_or_none()

                if existing_post:
                    # Update existing post
                    existing_post.title = post_data.get("title", existing_post.title)
                    existing_post.content = post_data.get("content", existing_post.content)
                    existing_post.url = post_data.get("url", existing_post.url)
                    existing_post.author = post_data.get("author", existing_post.author)
                    existing_post.comments = post_data.get("comments", existing_post.comments)
                    existing_post.collected_at = post_data.get("collected_at", datetime.utcnow())

                    # Parse created_at if it's a string
                    if "created_at" in post_data and post_data["created_at"]:
                        if isinstance(post_data["created_at"], str):
                            # For now, just store as is. We can add proper parsing later.
                            # This is a simplified version
                            existing_post.created_at = datetime.utcnow()
                        else:
                            existing_post.created_at = post_data["created_at"]

                    updated_count += 1
                    logger.info(f"Updated post: {post_data['external_id']}")
                else:
                    # Parse created_at if it's a string
                    created_at = post_data.get("created_at")
                    if isinstance(created_at, str):
                        # For now, use current time. We can add proper parsing later.
                        created_at = datetime.utcnow()
                    elif not created_at:
                        created_at = datetime.utcnow()

                    # Create new post
                    new_post = Post(
                        source=post_data["source"],
                        external_id=post_data["external_id"],
                        title=post_data.get("title", ""),
                        content=post_data.get("content", ""),
                        url=post_data.get("url", ""),
                        author=post_data.get("author", ""),
                        created_at=created_at,
                        collected_at=post_data.get("collected_at", datetime.utcnow()),
                        comments=post_data.get("comments", []),
                    )
                    session.add(new_post)
                    inserted_count += 1
                    logger.info(f"Inserted new post: {post_data['external_id']}")

            except Exception as e:
                logger.error(f"Failed to save post {post_data.get('external_id', 'unknown')}: {str(e)}")
                failed_count += 1
                continue

        await session.commit()
        logger.info(f"Saved posts: {inserted_count} inserted, {updated_count} updated, {failed_count} failed")

    except Exception as e:
        await session.rollback()
        logger.error(f"Error saving posts: {str(e)}")
        raise
    finally:
        if should_close:
            await session.close()

    return {
        "inserted": inserted_count,
        "updated": updated_count,
        "failed": failed_count,
    }


async def get_recent_posts(limit: int = 50, session: Optional[AsyncSession] = None) -> List[Post]:
    """
    Get recent posts from the database.

    Args:
        limit: Maximum number of posts to return
        session: Optional database session

    Returns:
        List of Post objects
    """
    should_close = False
    if session is None:
        session = AsyncSessionLocal()
        should_close = True

    try:
        stmt = select(Post).order_by(Post.collected_at.desc()).limit(limit)
        result = await session.execute(stmt)
        posts = result.scalars().all()
        return posts
    finally:
        if should_close:
            await session.close()
